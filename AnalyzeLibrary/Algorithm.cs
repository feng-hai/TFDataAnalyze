///////////////////////////////////////////////////////////
//  Algorithm.cs
//  Implementation of the Class Algorithm
//  Generated by Enterprise Architect
//  Created on:      24-4月-2016 9:16:28
//  Original author: FH
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using AnalyzeLibrary;
using AnalyzeLibrary.result;
using AnalyzeLibrary.protocol;
using AnalyzeLibrary.file;
using AnalyzeLibrary.Util;

namespace AnalyzeLibrary
{
    /// <summary>
    /// 实现接口算法
    /// </summary>
    public class Algorithm : IAlgorithm
    {

        private Protocol pro;
        private string[] data;
        /// <summary>
        /// 解析数据的协议
        /// </summary>
        public Protocol Pro
        {
            get
            {
                return pro;
            }

            set
            {
                pro = value;
            }
        }
        /// <summary>
        ///要被解析的数据
        /// </summary>
        public string[] Data
        {
            get
            {
                return data;
            }

            set
            {
                data = value;
            }
        }

        public Algorithm(string url, string[] data)
        {
            string str = DirFileHelper.GetFileStr(url);
            Protocol pro1 = (Protocol)XmlUtil.Deserialize(typeof(Protocol), str);
            this.Pro = pro1;
            this.Data = data;

        }

        ~Algorithm()
        {

        }

        /// <summary>
        /// 根据协议解析数据的方法
        /// </summary>
        public AnalyzeResult calculation()
        {
            AnalyzeResult aResult = new AnalyzeResult();
            foreach (string str in Data)
            {
                //string frameId = "0x212321321";
                //string value = "111101";
                aResult.ResultItme = analyzeFrame(str);
            }

            return aResult;
        }

        private List<AnalyzeResultItem> analyzeFrame(string value)
        {
            List<AnalyzeResultItem> ariList = new List<AnalyzeResultItem>();
            string timeStr = value.Substring(0, 48);

            var tempLength = value.Length;

            var valueLength = tempLength - 16 - 48;


            for (var i = 0; i < valueLength; i = i + 120)
            {
                string timeSpanStr = value.Substring(i + 47, 16);
                string frameId = value.Substring(i + 63, 32);
                string noStr = value.Substring(i + 95, 8);
                string valueStr = value.Substring(i + 103, 64);
                AnalyzeResultItem resultItem = new AnalyzeResultItem();
                resultItem.Id = frameId;
                //resultItem.Time=
                //查找帧的解析方式
                ProtocolFrame frame = pro.FrameList.Find(delegate (ProtocolFrame f)
                {
                    return f.FrameId == frameId;
                });
                if (frame == null)
                {
                    return null;
                }
                resultItem.Parameter = analyzeParameter(frame, value);
                ariList.Add(resultItem);
            }

            return ariList;
        }
        private List<ResultItemParameter> analyzeParameter(ProtocolFrame frame, string value)
        {
            List<ResultItemParameter> rip = new List<ResultItemParameter>();
            //解析参数项
            foreach (ProtocolFrameItem item in frame.FrameItemList)
            {
                ResultItemParameter para = new ResultItemParameter();
                para.Key = item.Name;
                int start = item.Start;
                int length = item.Length;
                string tempValue = value.Substring(start, length);
                int intValue = Convert.ToInt32(tempValue, 2);
                //para.Value = intValue * item.Resolution + item.Offset;
                rip.Add(para);
            }
            return rip;

        }

        private bool checkData(string value)
        {
            var tempLength = value.Length;
            var verificationCode = value.Substring(tempLength - 16 - 1, 16);
            var valueLength = tempLength - 16 - 48;
            var temp = valueLength % 120;
            if (temp == 0)
            {
                return true;
            }
            else {
                return false;
            }
        }
    }



    //end Algorithm



}//end namespace analyze